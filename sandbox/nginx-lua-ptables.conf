daemon on;
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    #jeremyb
    #lua_package_path "/opt/lua/scripts/?.lua;;";
    #lua_package_path "/usr/local/share/lua/5.1/?.lua;;";
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;
        #log_format postdata $request_body;
         #access_log  /var/log/nginx/postdata.log  postdata;
         #access_log  /one/app/openresty/nginx/logs/postdata.log  postdata;
         #access_log  /one/log/openresty/postdata.log  postdata;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #unset if editing lua file_code and you don't want to restart. default cache is set to on as performance takes a hit.
    #lua_code_cache off;

    init_by_lua "print('Using \"print\"');
    ngx.log(ngx.NOTICE, 'Using \"ngx.NOTICE\"');
    ngx.log(ngx.INFO, 'Using \"ngx.INFO\"')";

#start one-webfilter-blockpage
resolver 172.16.0.1 valid=10s;
 server  {
     # listen  x.x.x.186:80;
     # listen   x.x.x.186:443 ssl;
     # listen  [2600:7400:e00:1::21]:80;
     # listen   [2600:7400:e00:1::21]:443 ssl;
     listen [::]:443 ssl;
     listen 443 ssl;
     listen [::]:80;
     listen 80;
     #server_name server_for_eth0:0;
     #ssl    on;
     ssl_certificate   /private/selfsigned.crt;
     ssl_certificate_key    /private/selfsigned.key;
     #server_name  vapi.veracitynetworks.com;
     #location /webfilter_permit_request {
     #add_header Access-Control-Allow-Origin zoobey.com; # < this is the needed heade
#add_header 'Access-Control-Allow-Origin' '*';
     location /webfilter {
          #proxy_pass http://x.x.x.143:80;
          proxy_pass       http://demo-postgrest;
         #proxy_pass       http://x.x.x.183:13001;
      }
     #location / {
     location / {
        default_type 'text/plain';
        set $newuri ='';
        set $newargs ='';
        set $acl_account_id ='';
        set $account_id ='';
#add_header 'Access-Control-Allow-Origin' '*';
 access_by_lua_block {
            --ngx.say("hello there ")
            --local acl_account_id, err = rcon:hget("token:" .. token, "acl_account_id")
            local acl_account_id = '2,3,123'
            if acl_account_id == ngx.null then
                ngx.exit(ngx.HTTP_FORBIDDEN)
                --ngx.say("missing valid token")
            end

            --local account_id, err = rcon:hget("token:" .. token, "account_id")
            local account_id = '123'
            if account_id == ngx.null then
                ngx.exit(ngx.HTTP_FORBIDDEN)
                --ngx.say("missing account_id ")
            end
            --ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "o")
            ngx.var.acl_account_id = acl_account_id
            ngx.var.account_id = account_id
            --ngx.var._ = nil
            --ngx.var._ = nil
          --ngx.say(ngx.var.args.token)
          --ngx.log(ngx.NOTICE, ngx.var._);
            ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "o")
            --ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\bselect=[^&]*&?]],"", "o")
            ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.newargs, [[\b\_=[^&]*&?]],"", "o")
          --ngx.say(ngx.var.newargs)
          -- ngx.say(ngx.var.newargs)
          -- ngx.say(ngx.var.uri)
          -- ngx.say(ngx.var.account_acl_id)
          --ngx.say("missing account_id ")
            --ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "o")
            --works below
            --ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\bselect=[^&]*&?]],"", "o")
            --ngx.var.args_account_id = nil
            --ngx.var.args_account_id =
            --ngx.var.newargs = "" .. "account_id=2" .. "&acl_account_id=2,3,4"
            --ngx.var.args = nil



            -- if ngx.var.arg_token then
            --     token = ngx.var.arg_token
            -- end
            -- if ngx.var.cookie_token then
            --     token = ngx.var.cookie_token
            -- end
            -- if not token then
            --     --return ngx.redirect(invalidTokenURL)
            --     ngx.exit(ngx.HTTP_FORBIDDEN)
            -- end
            -- ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "o")
            -- ngx.var.acl_account_id = acl_account_id
            -- ngx.var.acl_account_id = acl_account_id
            --ngx.var._ =  
            --ngx.var.args =  ''
            
--local response = xml.new("response")
--ngx.say('<?xml version="1.0" encoding="UTF-8"?>', xml.str(response,0))
--ngx.say("zz test token")
--ngx.say({"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}})
--ngx.say('{"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}}')
--ngx.say(cjson.encode({ status = true }))  
--ngx.say('{"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}]}')

--ngx.status = ngx.HTTP_OK  
--ngx.header.content_type = "application/json; charset=utf-8"  
--ngx.say(cjson.encode({"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}}))
--ngx.say(cjson.encode({"data": [{"id":"2","name":"Account 1","note":"null"},{"id":"1","name":"Account Two","note":"null"},{"id":"3","name":"Account 3","note":"null"},{"id":"4","name":"Account 4","note":"null"}}))
--cjson = require "cjson"
--value = { true, { foo = "bar" } }
--json_text = cjson.encode(value)
--ngx.say(cjson.encode(json_text))
--ngx.say(cjson.encode({"a":2}))
--return ngx.exit(ngx.HTTP_OK)  

--ngx.say('{"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}]}')
--ngx.say('{"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}]}')
            --ngx.say("hello there ")
            --ngx.say(ngx.var.newargs)

          --      ngx.req.read_body()
          --      -- local oldbody = ngx.req.get_body_data()

          --      -- local cjson = require "cjson"
          --      -- json_string = oldbody
          --      -- table = cjson.decode(json_string)
          --      -- local newbody = "{"
          --      -- for k,v in pairs(table) do
          --      --     --ngx.log(ngx.NOTICE, k);
          --      --     --ngx.log(ngx.NOTICE, v);
          --      --     newbody = newbody..'"'..k..'":"'..v..'",'
          --      -- end
          --      -- k = "account_id"
          --      -- v = account_id
          --      -- newbody = newbody..'"'..k..'":"'..v..'",'
          --      -- newbody = string.sub(newbody, 0, #newbody-1)
          --      -- newbody = newbody.."}"
          --      -- ngx.log(ngx.NOTICE, newbody);

          --      newbody = {"data": [{"id":2,"name":"Account 1","note":null},{"id":1,"name":"Account Two","note":null},{"id":3,"name":"Account 3","note":null},{"id":4,"name":"Account 4","note":null}]}
          --      ngx.req.set_body_data(newbody)

}



         #proxy_pass http://x.x.x.183:13003/hello2/;
         #proxy_pass       http://x.x.x.183:13001;
         #proxy_pass       http://x.x.x.183:13001/public/;
         #proxy_pass http://demo-postgrest:3000$uri?account_id=in.$acl_account_id&$newargs;
         #proxy_pass http://demo-postgrest:3000$uri?account_id=in.$acl_account_id&$newargs;
         proxy_pass http://demo-postgrest:3000$uri?account_id=in.$acl_account_id&$newargs;
         #proxy_pass       http://demo-postgrest:3000&$newargs;
         #proxy_pass       http://demo-postgrest:3000;
     #add_header 'Access-Control-Allow-Origin' "$http_origin";
     #add_header 'Access-Control-Allow-Credentials' 'true';
         #proxy_pass       http://demo-postgrest:3000/account;
         #proxy_pass http://66.219.255.100;
     }
 }
#end one-webfilter-blockpage


# The default server.
server {
  #listen       80 default_server;
    listen [::]:443 ssl;
    listen 443 ssl;
    listen [::]:80;
    listen 80;
    #listen   x.x.x.182:443;
    #ssl    on;
#    ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
#    ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
     ssl_certificate   /private/selfsigned.crt;
     ssl_certificate_key    /private/selfsigned.key;
  server_name  everythingelse;

  error_page 404 /404.html;

  # Everything is a 404
  location / {
    return 404; #return the code 404
  }

  # link the code to the file
  #location = /custom_40x.html {
  location = /404.html {
    #EDIT this line to make it match the folder where there is your errors page
    #Dont forget to create 404.html in this folder
    #root  /var/www/nginx/errors/;
    root /one/app/openresty/nginx/html;
  }

error_page 500 502 503 504 /custom_50x.html;
 location = /custom_50x.html {
        root /one/app/openresty/nginx/html;
                internal;
        }
} # end everything server







server  {
    #listen  80;
    listen [::]:443 ssl;
    listen 443 ssl;
    listen [::]:80;
    listen 80;
    ssl_certificate   /private/selfsigned.crt;
    ssl_certificate_key    /private/selfsigned.key;
    #listen   x.x.x.182:443;
    # ssl    on;
    # ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
    # ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
    #lua_package_path "/usr/local/share/lua/5.1/?.lua;";



    server_name  zapi.zoobey.com;
        #add_header 'Access-Control-Allow-Origin' '*';   
        #add_header Access-Control-Allow-Origin *;   


    #location /vrf {
    location / {



#location ~* \.(eot|ttf|woff|woff2)$ {
#    add_header Access-Control-Allow-Origin *;
#}

     # if ($request_method = 'OPTIONS') {
     #    add_header 'Access-Control-Allow-Origin' '*';
     #    #
     #    # Om nom nom cookies
     #    #
     #    add_header 'Access-Control-Allow-Credentials' 'true';
     #    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
     #    #
     #    # Custom headers and headers various browsers *should* be OK with but aren't
     #    #
     #    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     #    #
     #    # Tell client that this pre-flight info is valid for 20 days
     #    #
     #    add_header 'Access-Control-Max-Age' 1728000;
     #    add_header 'Content-Type' 'text/plain charset=UTF-8';
     #    add_header 'Content-Length' 0;
     #    return 204;
     # }
     # if ($request_method = 'POST') {
     #    add_header 'Access-Control-Allow-Origin' '*';
     #    add_header 'Access-Control-Allow-Credentials' 'true';
     #    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
     #    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     # }
     # if ($request_method = 'GET') {
     #    add_header 'Access-Control-Allow-Origin' '*';
     #    add_header 'Access-Control-Allow-Credentials' 'true';
     #    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
     #    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
     # }











        default_type 'text/plain';
        set $newuri ='';
        set $newargs ='';
        set $acl_account_id ='';
        #access_by_lua_file /opt/openresty/nginx/file/acl_account_id.lua;
        access_by_lua_block {

  

 


            --json = require 'json'
                --ngx.log(ngx.NOTICE, 'Some Using \"ngx.NOTICE\"');
            local redis = require "resty.redis"
            local rcon = redis:new()
            --local res = rcon:auth("redismein")
            local redis_db = 0 
            rcon:set_timeout(1000)
            -- local res, err = rcon:auth("redismein")
            -- local res = redis_auth = redismein
            -- if not res then
            --     ngx.say("failed to authenticate rdb: ", err)
            --     return
            -- end

            assert(rcon:connect("127.0.0.1", 6379))
            assert(rcon:select(redis_db))

            -- if not ngx.var.arg_token then
            --     --ngx.say("no token")
            --     --ngx.exit()
            --     ngx.exit(ngx.HTTP_FORBIDDEN)
            -- end


            -- if ngx.var.arg_id then
            --     -- prefix = ngx.var.arg_prefix
            --     ngx.log(ngx.NOTICE, 'poopoohello');
            -- end
            --      ngx.log(ngx.NOTICE, 'jpoopoohello');


            if ngx.var.arg_token then
                token = ngx.var.arg_token
            end
            if ngx.var.cookie_token then
                token = ngx.var.cookie_token
            end
            if not token then
                --return ngx.redirect(invalidTokenURL)
                ngx.exit(ngx.HTTP_FORBIDDEN)
            end

            --local token = ngx.var.arg_token




            local acl_account_id, err = rcon:hget("token:" .. token, "acl_account_id")
            if acl_account_id == ngx.null then
                ngx.exit(ngx.HTTP_FORBIDDEN)
                --ngx.say("missing valid token")
            end

            local account_id, err = rcon:hget("token:" .. token, "account_id")
            if account_id == ngx.null then
                ngx.exit(ngx.HTTP_FORBIDDEN)
                --ngx.say("missing account_id ")
            end

            --ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "jo")
            -- will be cached within this cache if the regex option o (i.e., compile-once flag) is specified
            ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "o")
            ngx.var.acl_account_id = acl_account_id



            --start enforce database controls -- like subnet modification
            if ngx.var.uri
            then
                if 
                    string.find(ngx.var.uri, "/subnet$") or 
                    string.find(ngx.var.uri, "/testsubnet$") 
                then
                    local pgmoon = require("pgmoon");
                    local cjson = require("cjson");
                    local inspect = require("inspect");
                    local pg = pgmoon.new({
                        host = "x.x.x.181",
                        port = "5432",
                        database = "one",
                        user = "one"
                    });

                    assert(pg:connect())

                    if ngx.var.arg_id and string.find(ngx.var.uri, "/subnet$") then 
                        id = string.match(ngx.var.arg_id, '%d+')
                        ngx.log(ngx.NOTICE, id);
                        ngx.log(ngx.NOTICE, acl_account_id);
                        e_id = pg:escape_literal(id)
                        e_acl_account_id = pg:escape_literal(acl_account_id)
                        local sql = string.format("SELECT prefix, vrf_id FROM subnet WHERE account_id IN (%s) AND subnet.id = %d", acl_account_id, id);
                        ngx.log(ngx.NOTICE, sql);
                        local res = assert(pg:query(sql));
                        prefix = res[1].prefix
                        e_prefix = pg:escape_literal(prefix)
                        vrf_id = res[1].vrf_id
                        --ngx.log(ngx.NOTICE, inspect(res));
                        --ngx.log(ngx.NOTICE, res[1].prefix);
                        --local sql = string.format("SELECT prefix FROM subnet WHERE account_id IN (%s) AND %s << prefix", acl_account_id, prefix);
                        local sql = string.format("SELECT prefix FROM subnet WHERE account_id IN (%s) AND %s << prefix ORDER BY prefix DESC limit 1", acl_account_id, e_prefix);
                        ngx.log(ngx.NOTICE, sql);
                        local res = assert(pg:query(sql));
                        prefix_super = res[1].prefix
                        --if not prefix_super then deny access 
                        if not prefix_super then
                            ngx.exit(ngx.HTTP_FORBIDDEN)
                            --ngx.say("failed to connect: ", err)
                            --return

                                 --ngx.say("cate rdb: ", err)
                                 --ngx.say("modification of this prefix is not allowed by account")
                                 --return 404 "error";
                                 --return
                        end
                        --ngx.log(ngx.NOTICE, prefix_super);
                    end
                end
            end
            --end enforce database controls -- like subnet modification





            --modify post_data
            function add_post_key_value()
                ngx.req.read_body()
                local oldbody = ngx.req.get_body_data()
                -- grab the POST parameters as a table
                --local params = ngx.req.get_post_args()
                --args, err = ngx.req.get_post_args()
                --local args = ngx.req.get_uri_args()
                --ngx.req.set_uri_args(args)
                --ngx.log(ngx.NOTICE, oldbody);
                
                
                local cjson = require "cjson" 
                json_string = oldbody
                table = cjson.decode(json_string)
                local newbody = "{"
                for k,v in pairs(table) do
                    --ngx.log(ngx.NOTICE, k);
                    --ngx.log(ngx.NOTICE, v);
                    newbody = newbody..'"'..k..'":"'..v..'",'
                end
                k = "account_id"
                v = account_id 
                newbody = newbody..'"'..k..'":"'..v..'",'
                newbody = string.sub(newbody, 0, #newbody-1)
                newbody = newbody.."}"
                ngx.log(ngx.NOTICE, newbody);


                ngx.req.set_body_data(newbody)
            end


            if ngx.req.get_method() == "POST" then
              add_post_key_value()
            end
            -- if ngx.req.get_method() == "OPTIONS" then
            --     ngx.log(ngx.NOTICE, "OPTIONS tester");
            --   add_post_key_value()
            -- end


        }
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        #proxy_pass http://127.0.0.1:13000$uri?account_id=in.$acl_account_id&$newargs;
        #proxy_pass http://x.x.x.184:13000$uri?account_id=in.$acl_account_id&$newargs;
        proxy_pass http://x.x.x.184:13000$uri?account_id=in.$acl_account_id;
        #proxy_pass http://one-ap.veracitynetworks.com:13000$uri?account_id=in.$acl_account_id&$newargs;
    } #end vrf location



} #end vapi





#dispatch start

## server  {
##     #listen  80;
##     listen   x.x.x.182:443;
##     ssl    on;
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
##     server_name  dispatch.veracitynetworks.com;
##         #add_header 'Access-Control-Allow-Origin' '*';   
##         #add_header Access-Control-Allow-Origin *;   
## 
## 
##     location / {
## 
##         default_type 'text/plain';
##         set $newuri ='';
##         set $newargs ='';
##         set $acl_account_id ='';
##         #access_by_lua_file /opt/openresty/nginx/file/acl_account_id.lua;
##         access_by_lua_block {
##             --json = require 'json'
##                 --ngx.log(ngx.NOTICE, 'Some Using \"ngx.NOTICE\"');
##             local redis = require "resty.redis"
##             local rcon = redis:new()
##             --local res = rcon:auth("redismein")
##             local redis_db = 0 
##             rcon:set_timeout(1000)
##             -- local res, err = rcon:auth("redismein")
##             -- local res = redis_auth = redismein
##             -- if not res then
##             --     ngx.say("failed to authenticate rdb: ", err)
##             --     return
##             -- end
## 
##             assert(rcon:connect("127.0.0.1", 6379))
##             assert(rcon:select(redis_db))
## 
##             -- if not ngx.var.arg_token then
##             --     --ngx.say("no token")
##             --     --ngx.exit()
##             --     ngx.exit(ngx.HTTP_FORBIDDEN)
##             -- end
## 
## 
## 
## 
##             if ngx.var.arg_token then
##                 token = ngx.var.arg_token
##             end
##             if ngx.var.cookie_token then
##                 token = ngx.var.cookie_token
##             end
##             if not token then
##                 --return ngx.redirect(invalidTokenURL)
##                 ngx.exit(ngx.HTTP_FORBIDDEN)
##             end
## 
##             --local token = ngx.var.arg_token
## 
## 
## 
## 
##             local acl_account_id, err = rcon:hget("token:" .. token, "acl_account_id")
##             if acl_account_id == ngx.null then
##                 ngx.exit(ngx.HTTP_FORBIDDEN)
##                 --ngx.say("missing valid token")
##             end
## 
##             local account_id, err = rcon:hget("token:" .. token, "account_id")
##             if account_id == ngx.null then
##                 ngx.exit(ngx.HTTP_FORBIDDEN)
##                 --ngx.say("missing account_id ")
##             end
## 
##             --ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "jo")
##             -- will be cached within this cache if the regex option o (i.e., compile-once flag) is specified
##             ngx.var.newargs, n, err = ngx.re.gsub(ngx.var.args, [[\btoken=[^&]*&?]],"", "o")
##             ngx.var.acl_account_id = acl_account_id
## 
## 
##             --modify post_data
##             function add_post_key_value()
##                 ngx.req.read_body()
##                 local oldbody = ngx.req.get_body_data()
##                 -- grab the POST parameters as a table
##                 --local params = ngx.req.get_post_args()
##                 --args, err = ngx.req.get_post_args()
##                 --local args = ngx.req.get_uri_args()
##                 --ngx.req.set_uri_args(args)
##                 --ngx.log(ngx.NOTICE, oldbody);
##                 
##                 
##                 local cjson = require "cjson" 
##                 json_string = oldbody
##                 table = cjson.decode(json_string)
##                 local newbody = "{"
##                 for k,v in pairs(table) do
##                     --ngx.log(ngx.NOTICE, k);
##                     --ngx.log(ngx.NOTICE, v);
##                     newbody = newbody..'"'..k..'":"'..v..'",'
##                 end
##                 k = "account_id"
##                 v = account_id 
##                 newbody = newbody..'"'..k..'":"'..v..'",'
##                 newbody = string.sub(newbody, 0, #newbody-1)
##                 newbody = newbody.."}"
##                 ngx.log(ngx.NOTICE, newbody);
## 
## 
##                 ngx.req.set_body_data(newbody)
##             end
## 
## 
##             if ngx.req.get_method() == "POST" then
##               add_post_key_value()
##             end
##             if ngx.req.get_method() == "OPTIONS" then
##                 ngx.log(ngx.NOTICE, 'tester');
##               add_post_key_value()
##             end
## 
## 
##         }
##         proxy_set_header Host $host;
##         proxy_set_header X-Real-IP $remote_addr;
##         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
##         proxy_pass http://127.0.0.1:13000$uri?account_id=in.$acl_account_id&$newargs;
##     } #end vrf location
## 
## 
## 
## } #end dispatch 
## 
## 
## 
## 
## 
## 
## 
## 
## #start one.veracitynetworks.com
## #
## 
## server {
##     listen   x.x.x.182:80;
##     server_name  one.veracitynetworks.com;
##     return       301 https://one.veracitynetworks.com$request_uri;
## }
## server  {
##     #listen  80;
##     listen   x.x.x.182:443;
##     ssl    on;
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
##     server_name  one.veracitynetworks.com;
##     #     access_log  /one/app/openresty/nginx/logs/one.postdata.log  postdata;
## 
## error_page 500 502 503 504 /custom_50x.html;
## #  location = /custom_50x.html {
## #         root /one/app/openresty/nginx/html;
## #                 internal;
## #         }
##     #try_files $uri.html ui/$uri.html $uri ui/$uri;
##     
## 
##     #location ~* ^.+\.(js|css|png|jpg|jpeg|gif|ico)$ {
##     # location ~* ^.+\.(css|js|png|jpg|jpeg|gif|ico)$ {
##     #     proxy_pass http://127.0.0.1:8000;
##     # }
## #    location /vui/css {
## #        proxy_pass http://127.0.0.1:8000;
## #    }
##     # location /ui/js {
##     #     proxy_pass http://127.0.0.1:8000;
##     # }
##     # location /ui/inc {
##     #     proxy_pass http://127.0.0.1:8000;
##     # }
##      #location /netman/api/host/host-get-interfaces/ {
##      #    proxy_pass http://x.x.x.183:13003/netman/api/host-get-interfaces/;
##      #
##      #
##      #
##      #
##      #location /index.html {
##      #location ~* \.(gif|jpg|jpeg)$ {
##      location ~* \.(indexjj.html)$ {
##          if ($uri ~ "signin") {
##          proxy_pass http://x.x.x.183:18001$uri.html?$args;
##          }
## 
##         # if ($request_uri ~* "css") {
##         # proxy_pass       http://127.0.0.1:18001;
##         # }
##         proxy_pass       http://x.x.x.183:18001;
##         # 'off' is default; prevents changes to the Expires and Cache-Control headers
##         #    #expires off;
##     }
## 
## 
##      include includes/repo-generic.conf;
##      #include includes/api-generic.conf;
##      #jeremy here
##      include includes/api-generic-inline.conf;
##      location /netman/api/host/ {
##          proxy_pass http://x.x.x.183:13003/netman/api/host/;
##      }
##      location /netman/hello2/ {
##          proxy_pass http://x.x.x.183:13003/hello2/;
##      }
##      location /netman/hello/ {
##          proxy_pass http://x.x.x.183:13003/hello/;
##      }
##      location /netman/api/get-interfaces/host/ {
##          proxy_pass http://x.x.x.183:13003/netman/api/get-interfaces/host/;
##      }
##      location /jnetman/api/get-interfaces {
##          proxy_pass http://x.x.x.183:13003/hello/jeremy;
##      }
##      location /netman {
##          proxy_pass http://x.x.x.183:18002;
##      }
##      location /nfsen {
##          proxy_pass http://x.x.x.143:80;
##      }
##      # location /vflow {
##      #     proxy_pass http://x.x.x.143:80;
##      #     break;
##      # }
## 
##     # location ^~ /vflow {
##     #location /netman/vflow/ {
##     # location ~* \.(js|css|jpg|jpeg|gif|png|svg|ico|pdf|html|htm)$ {
##     #     expires     30d;
##     # }
## 
##     # location ~* \.php$ {
##     # }
##      
##     location /billing/files/ {
##          #proxy_pass http://x.x.x.183:13003/netman/api/host/;
##          #proxy_pass https://billing.veracitynetworks.com/apps/jtest/?dir=26640;
##          #proxy_pass https://billing.veracitynetworks.com/accounts/26640;
##          proxy_pass https://billing.veracitynetworks.com/accounts/26640/;
##      }
## 
##     location /netman/vflow/ {
##         #proxy_pass https://hosted-cluster;
##         #try_files $uri $uri/ /nfsen.php?$args;
##         #try_files $uri $uri/ /nfsen.php?$args;
##         #try_files $uri $uri/ /vflow/nfsen.php
##         # rewrite ^/vflow(/.*)$ $1 break;
##         # rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
##         #rewrite ^(/vflow/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
##         #rewrite ^/vflow/v(.*)\..*$ /nfsen/$1. last;
##         #rewrite ^/vflow/(.*)\..*$ /nfsen/$1.php last;
##         #
##         #rewrite ^/vflow/(.*) /vflow/$1.php last;
##         #rewrite ^/vflow/(.*) /vflow/$1.php last;
##         #rewrite ^/vflow/(.*) /vflow/$1 last;
##         #
##         #rewrite ^/netman/vflow/(.*) /vflow/$1 last;
## 
##         #try_files $uri $uri/ /yiiGuestbook/index.php?r=$request_uri;
##         #index index.php
##         #try_files $uri $uri/ $uri/index.php /index.php;
##         #rewrite ^/vflow/$ /nfsen/ break;
##         proxy_pass http://x.x.x.143:80;
## 
##         #proxy_pass http://x.x.x.143/nfsen/nfsen.php?$args:80;
##          proxy_set_header Host $host:$server_port;
##          proxy_set_header X-Real-IP $remote_addr;
##          proxy_set_header X-Forwarded-For $remote_addr;
##         # proxy_set_header X-Forwarded-Proto $scheme;
##          proxy_set_header X-Url-Scheme $scheme;
##          proxy_set_header X-Scheme $scheme;
##     }
## 
##         # location /vapi {
##         #     #proxy_pass       http://x.x.x.182:13000$uri?$newargs;
##         #     #proxy_pass       http://x.x.x.182:13000/subnet?$newargs;
##         #     proxy_pass       http://x.x.x.184:13000/subnet?$args;
##         #     #proxy_pass http://127.0.0.1:13002/$newuri&newargs;
##         # }
##      location /ui/assets {
##          proxy_pass http://x.x.x.183:18000;
##      }
##      location /ui/ejs {
##          proxy_pass http://x.x.x.183:18000;
##      }
##      location /ui/fonts {
##          proxy_pass http://x.x.x.183:18000;
##      }
##      location /ui/images {
##          proxy_pass http://x.x.x.183:18000;
##      }
##      # location /ui/ractive {
##      #     proxy_pass http://127.0.0.1:8000;
##      # }
## 
##     location / {
##         #rewrite "^$" /wiki/Main_Page;
##     # if ($forbidden) {
##     #     return 403;
##     # }
## 
##         #include includes/cors-wide-open.conf;
##         #include includes/cors-header-filter.conf;
##         #set $cors 'true';
## 
## 
## 
## 
## 
##      # if ($request_method = 'OPTIONS') {
##      #    add_header 'Access-Control-Allow-Origin' '*';
##      #    #
##      #    # Om nom nom cookies
##      #    #
##      #    add_header 'Access-Control-Allow-Credentials' 'true';
##      #    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
##      #    #
##      #    # Custom headers and headers various browsers *should* be OK with but aren't
##      #    #
##      #    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
##      #    #
##      #    # Tell client that this pre-flight info is valid for 20 days
##      #    #
##      #    add_header 'Access-Control-Max-Age' 1728000;
##      #    add_header 'Content-Type' 'text/plain charset=UTF-8';
##      #    add_header 'Content-Length' 0;
##      #    return 204;
##      # }
##      # if ($request_method = 'POST') {
##      #    add_header 'Access-Control-Allow-Origin' '*';
##      #    add_header 'Access-Control-Allow-Credentials' 'true';
##      #    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
##      #    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
##      # }
##      # if ($request_method = 'GET') {
##      #    add_header 'Access-Control-Allow-Origin' '*';
##      #    add_header 'Access-Control-Allow-Credentials' 'true';
##      #    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
##      #    add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
##      # }
## 
## 
## 
## 
## 
## 
## 
## 
## 
## #add_header Set-Cookie foo=1033;
##         set $newuri ='';
##         set $newargs ='';
##         #return 200 $http_cookie;
##         #return 200 $cookie_token;
##         #set $invalidTokenURL ='http://vlogin.veracitynetworks.com/?status=invalidToken';
##  #          content_by_lua '
##  #    ngx.header["My-header"]= "foo"
##  #               return ngx.redirect("http://vlogin.veracitynetworks.com/test.html")
##  #  ';
## 
##         access_by_lua_block {
##             local invalidTokenURL = 'https://vlogin.veracitynetworks.com/signin?status=invalidToken'
##             local invalidTokenURL2 = 'https://vlogin.veracitynetworks.com/poo?status=invalidToken'
##             local redis = require "resty.redis"
##             local rcon = redis:new()
##             local redis_db = 0 
##             rcon:set_timeout(1000)
##             assert(rcon:connect("127.0.0.1", 6379))
##             assert(rcon:select(redis_db))
## 
## 
##             if ngx.var.arg_token then
##                 token = ngx.var.arg_token
##             end
##             if ngx.var.cookie_token then
##                 token = ngx.var.cookie_token
##             end
##             if not token then
##                 return ngx.redirect(invalidTokenURL)
##             end
## 
##             local acl_account_id, err = rcon:hget("token:" .. token, "acl_account_id")
##             if acl_account_id == ngx.null then
##             end
## 
##             local account_id, err = rcon:hget("token:" .. token, "account_id")
##             if account_id == ngx.null then
##                 return ngx.redirect(invalidTokenURL)
##             end
##                 --ngx.say("zz test token")
##             
##             --ngx.var.newargs = ngx.var.args .. "account_id=2" .. "acl_account_id=2,3,4" 
##             ngx.var.newargs = "" .. "account_id=2" .. "&acl_account_id=2,3,4" 
##             --ngx.var.args_account_id = '2'
##             --ngx.var.args_acl_account_id = '2,3.4'
##             
## 
##             -- redirect based on content
##             -- if ngx.var.request_body and
##             --     string.find(ngx.var.request_body, "192")
##             -- then
##             --     return ngx.redirect("google.com")
##             -- end
##             
##             -- create extensionless uri 
##             ngx.var.newuri = ngx.var.uri;
##             if ngx.var.uri
##             then
##                 if 
##                     string.find(ngx.var.uri, "/index$") or 
##                     string.find(ngx.var.uri, "/ui/itemgraph$") or 
##                     string.find(ngx.var.uri, "/ui/subnet$") or 
##                     string.find(ngx.var.uri, "/ui/material$") or 
##                     string.find(ngx.var.uri, "/ui/materialbootstrap$") or 
##                     string.find(ngx.var.uri, "/ui/ipaddr$") or 
##                     --string.find(ngx.var.uri, "/ui/ipam/ipaddr$") or 
##                     string.find(ngx.var.uri, "/ui/ipam/address$") or 
##                     string.find(ngx.var.uri, "/ui/ipam/subnet$") or 
##                     string.find(ngx.var.uri, "/ui/webfilter/subnet$") or 
##                     string.find(ngx.var.uri, "/ui/webfilter/request-to-allow$") or 
##                     string.find(ngx.var.uri, "/ui/webfilter/request_to_allow$") or 
##                     string.find(ngx.var.uri, "/ui/webfilter/request$") or 
##                     string.find(ngx.var.uri, "/ui/test$") 
##                 then 
##                     ngx.var.newuri = ngx.var.uri .. ".html"
##                 -- else
##                 --     return ngx.redirect("/ui/subnet")
##                 end
##             end
## 
##         }
##         #proxy_pass http://127.0.0.1:13000$uri?account_id=in.$acl_account_id&$newargs;
##         #proxy_pass http://127.0.0.1:10080;
##         #try_files $uri $uri/ $uri.html @node;
##         #proxy_pass http://127.0.0.1:8000$uri.html;
##         
##         proxy_set_header Host $host;
##         proxy_set_header X-Real-IP $remote_addr;
##         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
##         #proxy_set_header Access-Control-Allow-Origin: $http_origin;
##         #proxy_add_header 'Access-Control-Allow-Origin' "$http_origin";
##         #proxy_pass http://127.0.0.1:8000;
##         #proxy_pass http://127.0.0.1:8000$uri?account_id=in.$acl_account_id&$newargs;
##         #proxy_pass http://127.0.0.1:8000$uri?account_id=in.$acl_account_id&$newargs;
##         #proxy_pass http://127.0.0.1:18000$newuri?account_id=in.$acl_account_id&$newargs;
##         location /dispatch/ {
##             proxy_pass       http://x.x.x.183:13002$uri?$newargs;
##             #proxy_pass http://127.0.0.1:13002/$newuri&newargs;
##         }
##         proxy_pass http://x.x.x.183:18000$newuri;
##         #proxy_pass http://127.0.0.1:8000$uri?$newargs;
##         #proxy_pass http://127.0.0.1:8000$uri?$args;
##         #proxy_pass http://127.0.0.1:8000$uri;
##         #proxy_pass http://127.0.0.1:8000$uri?$args;
## 
##         #proxy_pass http://127.0.0.1:8000$uri.html?$args;
##     } #end root location
## 
## }
## #end one.veracitynetworks.com
## 
## 
## #start joomla
## server {
##     #    listen 80;
##     listen   x.x.x.182:443;
##     ssl    on;
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
##         server_name  vdoc.veracitynetworks.com;
##         server_name_in_redirect off;
##         root /one/app/joomla/vdoc.veracitynetworks.com;
## 
##         access_log /one/app/openresty/nginx/logs/vdoc.access_log;
##         error_log /one/app/openresty/nginx/logs/error_log info;
## 
##         #root PATH_ON_SERVER;
##         index index.php index.html index.htm default.html default.htm;
##         # Support Clean (aka Search Engine Friendly) URLs
##         location / {
##                 try_files $uri $uri/ /index.php?$args;
##         }
## 
##         # deny running scripts inside writable directories
##         location ~* /(images|cache|media|logs|tmp)/.*\.(php|pl|py|jsp|asp|sh|cgi)$ {
##                 return 403;
##                 error_page 403 /403_error.html;
##         }
## 
##         location ~ \.php$ {
##             fastcgi_pass  127.0.0.1:9000;
##             fastcgi_index index.php;
##             include fastcgi_params;
##             fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
##             include /one/app/openresty/nginx/conf/fastcgi.conf;
##             #include /etc/nginx/fastcgi.conf;
##         }
## 
##         # caching of files 
##         location ~* \.(ico|pdf|flv)$ {
##                 expires 1y;
##         }
## 
##         location ~* \.(js|css|png|jpg|jpeg|gif|swf|xml|txt)$ {
##                 expires 14d;
##         }
## 
## }
## #end joomla
## 
## 
## #start login
## server  {
##     #listen  80;
##     listen   x.x.x.182:443;
##     ssl    on;
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
##     server_name  vlogin.veracitynetworks.com;
##     location /auth {
##         proxy_pass       http://x.x.x.183:13001;
##     }
##      location /jsi {
##          proxy_pass http://x.x.x.183:18001;
##      }
##      location /cssi {
##          proxy_pass http://x.x.x.183:18001;
##      }
##      location /css {
##          proxy_pass http://x.x.x.183:18001;
##      }
##      location /js {
##          proxy_pass http://x.x.x.183:18001;
##      }
##      location /img {
##          proxy_pass http://x.x.x.183:18001;
##      }
## 
##         # location / {
##         #         try_files $uri $uri/ /index.php?$args;
##         # }
##     location / {
##         #cors-wide-open
##         #
##         #include includes/cors-wide-open.conf;
##         #set $cors 'true';
##                 #try_files $uri $uri/ /index.php?$args;
##         #try_files $uri $uri.html $uri/
##         # add_header 'Access-Control-Allow-Origin' '*';
##         # add_header 'Access-Control-Allow-Credentials' 'true';
##         # add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
## 
##         # proxy_set_header X-Real-IP          $remote_addr;
##         # proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
##         # proxy_set_header Host               $http_host;
##         # proxy_set_header X-Forwarded-Host   $host;
##         # proxy_set_header X-Forwarded-Server $host;
##         #proxy_pass       http://127.0.0.1:18001;
##         #proxy_pass       http://127.0.0.1:18001;
##         #if ($request_uri ~* "signin") {
## #jeremy        
##          if ($uri ~ "signin") {
##          proxy_pass http://x.x.x.183:18001$uri.html?$args;
##          }
## 
##         # if ($request_uri ~* "css") {
##         # proxy_pass       http://127.0.0.1:18001;
##         # }
##         proxy_pass       http://x.x.x.183:18001;
##         # 'off' is default; prevents changes to the Expires and Cache-Control headers
##         #    #expires off;
##     }
## }
## #end login
## 
## #start login
## server  {
##     #listen  80;
##     listen   x.x.x.182:443;
##     ssl    on;
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
## 
##     server_name  vauth.veracitynetworks.com;
##     location / {
##     #return 200 "hello world";
## # if ($request_method = 'POST') {
## #         add_header 'Access-Control-Allow-Origin' '*';
## #         add_header 'Access-Control-Allow-Credentials' 'true';
## #         add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
## #         add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
## #      }
## 
##         # proxy_set_header X-Real-IP          $remote_addr;
##         # proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
##         # proxy_set_header Host               $http_host;
##         # proxy_set_header X-Forwarded-Host   $host;
##         # proxy_set_header X-Forwarded-Server $host;
##         #
##         
##         proxy_pass       http://127.0.0.1:13001;
##         proxy_set_header Host $host;
##         proxy_set_header X-Real-IP $remote_addr;
##         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
## 
## 
##         # 'off' is default; prevents changes to the Expires and Cache-Control headers
##         #    #expires off;
##     }
## }
## #end login
## 
## # start vvapi - super secret backdoor
## server  {
##     listen   x.x.x.182:443;
##     ssl    on;
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
## 
## 
## 
##     server_name  vvapi.veracitynetworks.com;
##     #location /vrf {
##     location / {
##         # proxy_pass       http://127.0.0.1:13001;
##         # proxy_pass http://x.x.x.184:13000$uri?account_id=in.$acl_account_id&$newargs;
##         proxy_pass http://x.x.x.184:13000;
##         proxy_set_header Host $host;
##         proxy_set_header X-Real-IP $remote_addr;
##         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
##     }
## } # end vvapi
## 
## 
## 
## #START aone 
## server {
##     listen   x.x.x.182:80;
##     server_name  aone.veracitynetworks.com;
##     return       301 https://aone.veracitynetworks.com$request_uri;
## }
## 
## 
## #
## 
## server {
##     listen x.x.x.182:443 ssl;
##     server_name aone.veracitynetworks.com;
## 
##     ssl_certificate   /etc/pki/tls/private/veracitynetworks.com.chained.crt;
##     ssl_certificate_key    /etc/pki/tls/private/veracitynetworks.com.key;
## 
##     ssl_session_cache shared:SSL:20m;
##     ssl_session_timeout 45m;
## 
##     ssl_prefer_server_ciphers on;
## 
##     ssl_ciphers "ECDH+AESGCM:ECDH+AES256:ECDH+AES128:DH+3DES:!ADH:!AECDH:!MD5:!DH";
## 
##     ssl_stapling on;
##     ssl_stapling_verify on;
## 
##     #resolver 8.8.8.8;
##     resolver x.x.x.211 208.72.160.67;
## 
## 
##     # location /jira {
##     #     proxy_set_header X-Forwarded-Host $host;
##     #     proxy_set_header X-Forwarded-Server $host;
##     #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
##     #     proxy_pass http://192.168.212.108:7990/;
##     #     client_max_body_size 10M;
##     # }
##     #
##     #
## 
## 
## #     location /repo/ {
## #         #proxy_pass http://repo.veracitynetworks.com:80/netman/api/host/;
## #         #proxy_pass http://repo.veracitynetworks.com/:80;
## #         proxy_pass http://repo.veracitynetworks.com:80/repo/;
## #         #proxy_pass http://repo.veracitynetworks.com/test.html:80;
## #     }
## #     location /repo/jquery/ {
## #         proxy_pass http://repo.veracitynetworks.com:80/repo/lib/node_modules/jquery/dist/;
## #     }
## #     location /repo/bootstrap/ {
## #         proxy_pass http://repo.veracitynetworks.com:80/repo/lib/node_modules/bootstrap/dist/;
## #     }
##     include includes/repo-generic.conf;
## 
## #    location /zimbra/admin/ {
## #location ~ /zimbra/admin/(?<section>.*)/index.html {
## #location ~ /zimbra/admin/(?<section>.*) {
## location /zimbra/admin/ {
##   # block one workstation
##   #   deny    192.168.1.1;
##   #     # allow anyone in 192.168.1.0/24
##   allow   x.x.x.17;
##   #         # drop rest of the world
##              deny    all;
##         # rewrite ^/zimbra/admin(/.*)$ $1 break;
##         # #rewrite ^/nagios(/.*)$ $1 break;
##         # #proxy_pass  http://10.0.21.8:80/;
##         # #proxy_pass http://x.x.x.183:13005/form;
##         # proxy_pass http://x.x.x.183:13005/;
##         #proxy_pass http://x.x.x.183:13005/;
## #location ~ /some/path/(?<section>.*)/index.html {
##     #proxy_pass http://x.x.x.183:13005/$section;
##     proxy_pass http://x.x.x.183:13005/;
##     proxy_set_header Host $host;
## 
##     }
##     location /netman/api/host/ {
##         proxy_pass http://x.x.x.183:13003/netman/api/host/;
##     }
##     location /netman/hello2/ {
##         proxy_pass http://x.x.x.183:13003/hello2/;
##     }
##     location /netman/hello/ {
##         proxy_pass http://x.x.x.183:13003/hello/;
##     }
##     location /netman/api/get-interfaces/host/ {
##         proxy_pass http://x.x.x.183:13003/netman/api/get-interfaces/host/;
##     }
##     location /jnetman/api/get-interfaces {
##         proxy_pass http://x.x.x.183:13003/hello/jeremy;
##     }
##     location /netman {
##         proxy_pass http://x.x.x.183:18002;
##     }
##     location /nfsen {
##         proxy_pass http://x.x.x.143:80;
##     }
## 
##     location /netman/vflow/ {
##         #proxy_pass https://hosted-cluster;
##         #try_files $uri $uri/ /nfsen.php?$args;
##         #try_files $uri $uri/ /nfsen.php?$args;
##         #try_files $uri $uri/ /vflow/nfsen.php
##         # rewrite ^/vflow(/.*)$ $1 break;
##         # rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
##         #rewrite ^(/vflow/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
##         #rewrite ^/vflow/v(.*)\..*$ /nfsen/$1. last;
##         #rewrite ^/vflow/(.*)\..*$ /nfsen/$1.php last;
##         #
##         #rewrite ^/vflow/(.*) /vflow/$1.php last;
##         #rewrite ^/vflow/(.*) /vflow/$1.php last;
##         #rewrite ^/vflow/(.*) /vflow/$1 last;
##         #
##         #rewrite ^/netman/vflow/(.*) /vflow/$1 last;
## 
##         #try_files $uri $uri/ /yiiGuestbook/index.php?r=$request_uri;
##         #index index.php
##         #try_files $uri $uri/ $uri/index.php /index.php;
##         #rewrite ^/vflow/$ /nfsen/ break;
##         proxy_pass http://x.x.x.143:80;
## 
##         #proxy_pass http://x.x.x.143/nfsen/nfsen.php?$args:80;
##          proxy_set_header Host $host:$server_port;
##          proxy_set_header X-Real-IP $remote_addr;
##          proxy_set_header X-Forwarded-For $remote_addr;
##         # proxy_set_header X-Forwarded-Proto $scheme;
##          proxy_set_header X-Url-Scheme $scheme;
##          proxy_set_header X-Scheme $scheme;
##     }
## 
##  
## 
## 
##     location / {
##         proxy_pass http://x.x.x.183;
##         proxy_set_header Host $host:$server_port;
##         proxy_set_header X-Real-IP $remote_addr;
##         proxy_set_header X-Forwarded-For $remote_addr;
##         proxy_set_header X-Forwarded-Proto $scheme;
##         proxy_set_header X-Url-Scheme $scheme;
##         proxy_set_header X-Scheme $scheme;
##     } 
## } #END server aone 


} #end http

